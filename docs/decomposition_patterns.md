# Decomposition patterns

Разделил компоненты на несколько и стало только хуже?
Паттерны декомпозиции кода, которые позволяют достигать [Low coupling/High cochesion](https://habr.com/ru/companies/otus/articles/505852/).

- [Slot](#slot) _(props drilling, god object)_
- [Render props](#render-props) _(props drilling, god object)_
- [Hooks flow](#hooks-flow) _(god object)_
- [Local global states](#local-global-states) _(god object)_
- [Mediator](#mediator)

## Slot

_(props drilling, god object)_

![](./schemes/slot_pic.png)

**Проблема**

- У компонента слишком много ответственностей

**Решение**

- Можно делегировать отрисовку части компонентов родителю и получить их через пропсы

**Преимущества и недостатки**

- ✅ Решает проблему пропс дриллинга
- ✅ Увеличивает переиспользование
- ❌ Блокирует React.memo
- ❌ Плоховато читается

**Заметки**

- Не стоит сильно дробить, чтобы не создать бесполезные компоненты

---

&nbsp;

## Render props

_(props drilling, god object)_

Усложненная версия паттерна [Slot](#slot). Отличие - передается не ReactNode, а функция, которая возвращает ноду: () => ReactNode. Как именно отрисовывается определяет внешний код, но появляется возможность повлиять на отрисовку внутренним состоянием компонента.

![](./schemes/render_props_pic.png)

**Проблема**

- У компонента слишком много ответственностей, но использование [Slot](#slot) невозможно, так как дочерние компоненты зависят от локального состояния

**Решение**

- Принимается не сам React элемент, а стратегия его отрисовки (() => ReactNode), в которую компонент, который отрисосвывает этот элемент, может прокинуть параметры

**Преимущества и недостатки**

- ✅ Решает проблему пропс дриллинга
- ✅ Увеличивает переиспользование
- ✅ Позволяет инкапсулировать состояние
- ❌ Блокирует React.memo
- ❌ Плоховато читается

---

&nbsp;

## Hooks flow

![](./schemes/hooks_flow_pic.png)

**Проблема**

- Не получается разделить логику на хуки, так как логика работает с общими данными

**Решение**

- Данные могут перетекать из хука в хук, пока не попадут в компонент. Каждый хук отвечает за свою часть преобразования данных

**Преимущества и недостатки**

- ✅ Инкапсуляция логики
- ❌ Сложно составить общую картину

---

&nbsp;

## Local global states

![](./schemes/local_global_state_pic.png)

**Проблема**

- В результате декомпозиции двум компоненам/хукам нужен доступ к состоянию, но это состояние не нужно внешнему коду - из-за ограничений реакта необходимо вынести состояние за перделы компонента, чтобы иметь возможность их связать

**Решение**

- Сделать контекст (модуль стейт менеджера) локальным для этих компонентов

**Преимущества и недостатки**

- ✅ Сокрытие подробностей
- ✅ Увеличивает надежность (у внешнего кода нет доступа к большому количеству пропсов)
- ❌ Провайдеры

---

&nbsp;

## Mediator

![](./schemes/mediator_pic.png)

**Проблема**

- Связи между компонентами размазаны по системе, и их сложно отследить

**Решение**

- Создать компонент/хук/фукнцию "медиатор", которые связывают другие компоненты вместе

**Преимущества и недостатки**

- ✅ Отделение связей в отдельный модуль - делает связи проще для понимания
- ✅ Минимизирует связи модулей напрямую - увеличивает их надежность
- ❌ Модули больше не могут взаимодействовать напрямую
